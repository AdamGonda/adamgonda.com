---
layout: post
author: Adam Gonda
minutes: 5
tags:
  - Tutorial
  - Coding
  - Game
  - JavaScript
titles:
  - Intro
  - Example
  - Conclusion
---

The goal of this post is to introduce the console-runner package.
Show it's API through a toy example and tell a bit about it's inner workings.

{% include post-content-list.html titles=page.titles %}

# Intro

If you ever created a game before, you know that
in every game, there is a game loop at the core,
and it's job is to keep updating the game until we exit.
In this case the console-runner will provide our game loop
besides it's other responsibilities ⬇️

{% include post-image.html
  src='snake-overview.jpg'
  date=page.date
%}

It is a nice practice to separate the presentation
from the business logic. This approach simplifies
our application and sets clear boundaries.
So when we implement the game, our only job will be
to deal with the game specific issues.

# Example

I like to start simple but first we need to prepare for the example.

<p>Create a folder and open it with VS Code:</p>{: .pre-code}
```js
mkdir snake-game && cd snake-game && code .
```

<p>Create a package.json file:</p>{: .pre-code}
```js
npm init -y
```

<p>Create a game.js file:</p>{: .pre-code}
```js
touch game.js
```

<p>Install the console-runner package:</p>{: .pre-code}
```js
npm i adamgonda/console-runner
```
---

So as I said the only function that we
need from the `console-runner` is `run`.
In this example we create a 20 x 10
"game" where the player at the middle
rendered as an "X".


```js
const { run } = require('console-runner')

run({
  initialState: {
    player: {
      x: 10,
      y: 5,
    },
  },
  toCommon: state => [
    {
      ...state.player,
      tag: 'player',
    },
  ],
  update: (state, input) => state,
  renderMap: {
    player: 'X',
  },
  dimensions: {
    WIDTH: 20,
    HEIGHT: 10,
  },
})
```

**initialState**: will be the starting point of our game,
here we provide a state that we like to have at the
beginning

**toCommon**: is a function that is specific to a given game,
it's job is to transform the game state into a common format,
which is a list of objects, that has
an `x`, `y` and a `tag` property. So the `console-runner`
knows where and how to render them.

**update**: is a function that holds our game logic,
the `console-runner` calls it before every render.
it gets a state and an input from the
`console-runner` than returns a new state

**renderMap**: here you can specify a mapping between tags
to ASCII characters, so the `console-runner` will
render your game as you like

**dimensions**: tells how big view the `console-runner` has to create

---

If you did everything right, you has to see something like this

```js
{ player: { x: 10, y: 5 } }
input null
-----------------------
|                     |
|                     |
|                     |
|                     |
|                     |
|          X          |
|                     |
|                     |
|                     |
|                     |
|                     |
-----------------------
```

# Conclusion



In the next post we will...
